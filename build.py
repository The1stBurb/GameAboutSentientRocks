#"":{"inps":[":",":"],"outs":[":",":"],"truthTable":["00|","10|","01|","11|"],"info":"","notation":"&&"},
gates={
    "NOT":{"inps":["a:1"],"outs":["c:1"],"truthTable":["0|1","1|0"],"info":"The most basic Logic Gate, the NOT gate. It returns a 1 when a is 0, and a 0 when a is 1. Its notation is \"¬\" and the squigly thingy \"~\" (why does this exsist).","notation":"!"},
    "AND":{"inps":["a:1","b:1"],"outs":["c:1",],"truthTable":["00|0","10|0","01|0","11|1"],"info":"This is an AND gate. It gives a 1 when a AND b are 1. The notation used is \"^\" or a \"*\" (which I like more), the multiplication symbol, because 0*0, 0*1, and 1*0=0, but 1*1=1."},
    "NAND":{"inps":["a:1","b:1"],"outs":["c:1",],"truthTable":["00|1","10|1","01|1","11|0"],"info":"This one you have. It is an AND gate with a NOT tacked on to the output, and so giving a 1 unless a AND b are 1. This is it's notationm, \"↓\", which I don't understand."},
    "OR":{"inps":["a:1","b:1"],"outs":["c:1",],"truthTable":["00|0","10|1","01|1","11|1"],"info":"This is an OR gate. It gives a 1 when a OR b is 1. The notation used is \"v\" or \"+\" (which i like better), because 0+0=0, but 1+0, 0+1, and (aparently) 1+1=1."},
    "NOR":{"inps":["a:1","b:1"],"outs":["c:1",],"truthTable":["00|1","10|0","01|0","11|0"],"info":"This is a NOR gate. Its like the NAND gate, but has an OR with a NOT-ed output. It gives an 1 when a AND b are 0. The notation used is wacky like NAND's, being \"↑\"."},
    "XOR":{"inps":["a:1","b:1"],"outs":["c:1",],"truthTable":["00|0","10|1","01|1","11|0"],"info":"This is an XOR gate, or Exclusive OR. It returns a 1 when a OR b is 1 AND a≠b (not equal). It has a slightly sense making symbol, \"⊕\"."},
    "XNOR":{"inps":["a:1","b:1"],"outs":["c:1",],"truthTable":["00|1","10|0","01|0","11|1"],"info":"Then, last of the basic Logic Gates, the XNOR. If you couldn't guess, a XOR with a NOT-ed output. It returns a 1 when a=b. It's notation is \"↔\"."},
    "1BitAdder":{"inps":["a:1","b:1","carryIn:1"],"outs":["sum:1","carryOut:1"],"truthTable":["000|00","100|10","010|10","110|01","001|10","011|01","101|01","111|11"],"info":"This is used to add single bit numbers together (1 or 0). Its not very useful, but when you have 8 or 16 or 32, now you can add nu,bers as bIg as 256 or 65,536 or 4,294,967,296. yay. It has 2 inputs and a carryIn/Out. The carry is used the same way it is in decimal arithmetic: if you have 2 numbers (lets say 14 and 8), well those make 22, which is bigger than 9. If there is no carry, 14+8=2 which is not right. The carry would tell us \"HEY you made a BIG number so add a 1 to the next columns calculations!\". Here, the hooman would add 4+8=2, carry 1. we carry the one and get 1 (that was carried) +1+0=2. now we then get 22 yay all is not lost"},
    "8BitAdder":{"inps":["a:8:","b:8","carryIn:1"],"outs":["sum:8","carryOut:1"],"truthTable":["<math:a+b|sum><max:2^8|carryOut>"],"info":"Yea, i seriously hope this isn't too hard... (dont worry if you mess up the carrys lol i do)","notation":"&&"},
    "ALU-V1":{"inps":["a:8","b:8","op:1"],"outs":["c8","carry:1","zero:1"],"truthTable":["<math:op=0?a+b:a-b|sum><max:2^8|carry<min:0|zero>"],"info":"This is a Arithmetic Logic Unit, but slightly boring. We'll make better versions later! All this does is Addition if op is 0, Subtraction if op is 1. The Carry flag activates if it the adder overflows (aka making a number above 255 aka the carry out on the MSB is 1). The Zero flag activates if the sum is 0 (wow crazy)"},
    # "clock":{"inps":["",""],"outs":["",""],"truthTable":["|","|"]},
}